\documentclass[12pt]{article}
\usepackage{lingmacros}
\usepackage{tree-dvips}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{tabularx}

\begin{document}

\newcommand\alphaeq{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny $\alpha$}}}{=}}}
\newcommand\betaeq{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny $\beta$}}}{=}}}
\newcommand\betaetaeq{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny $\beta\eta$}}}{=}}}


\section*{Задача 2.3}
\begin{itemize}
		\item  $(x, x) \in \alphaeq$
		\item $(A, A) \in \alphaeq$
		\item ако $(A_1, A_2) \in \alphaeq$, то $(A_2, A_1) \in \alphaeq$
		\item ако $(A_1, A_2) \in \alphaeq$ и $(A_2, A_3) \in \alphaeq$, то $(A_1, A_3) \in \alphaeq$
		\item ако $(A_1, B_1) \in \alphaeq$ и $(A_2, B_2) \in \alphaeq$, то $(A_1 B_1, A_2 B_2) \in \alphaeq$
		\item Нека имаме $M = \lambda_x A$, $N = \lambda_y B$. Ако $x \notin FV(B)$ и $(A, B[y \rightsquigarrow x]) \in \alphaeq$, то $(M, N) \in \alphaeq$ (тук $\rightsquigarrow$ е наивна субституция)
\end{itemize}

\section*{Задача 2.1}
\subsection*{(1)}
\paragraph*{}
Ще напрваим индукция по дефиницията на частичната субституция.
\begin{enumerate}
	\item $M \equiv x$. В този случай $M[x \rightsquigarrow N] \equiv N$ и $M[x \hookrightarrow N] \equiv N$.
	\item $M \equiv y$, $y \not\equiv x$. В този случай $M[x \rightsquigarrow N] \equiv y$ и $M[x \hookrightarrow N] \equiv y$.
	\item $M \equiv M_1M_2$. Тогава $M[x \rightsquigarrow N] = (M_1[x \rightsquigarrow N])(M_2[x \rightsquigarrow] N)$ и $M[x \hookrightarrow N] = (M_1[x \hookrightarrow N])(M_2[x \hookrightarrow N])$. От ИП $(M_1[x \rightsquigarrow N]) \equiv (M_1[x \hookrightarrow N])$ и $(M_2[x \rightsquigarrow N]) \equiv (M_2[x \hookrightarrow N])$. Също от ИП знаем, че двете частични субституции са дефинирани. Така получаваме, че $M[x \rightsquigarrow N] \equiv M[x \hookrightarrow N]$, а също сме и сигурни, че $M[x \hookrightarrow N]$ е дефинирано.
	\item $M = \lambda_x P$. Тогава $M[x \rightsquigarrow N] \equiv \lambda_x P$ и $M[x \hookrightarrow N] \equiv \lambda_x P$, така получаваме, че $M[x \rightsquigarrow N] \equiv M[x \hookrightarrow N]$.
	\item $M = \lambda_y P$ за $y \not\equiv x$. Ясно е, че ако частичната субституция е дефинирана в този случай, то резултатите от двете субституции ще съпвадат. Това, което трябва да се покаже е, че частичната субституция е дефинирана в този случай. По-конкретно трябва да покажем, че $x \not\in FV(P)$ или $y \not\in FV(N)$. Ще използваме допускането от задачата, че $FV(N) \cap BV(M) = \{ \}$. 
	\paragraph*{}
	От дефиницията на $BV$ може да се види, че $y \in BV(M)$. Понеже $FV(N) \cap BV(M) = \{ \}$, то излиза, че $y \not\in FV(N)$. Това показва, че частичната субституция е дефинирана.
	\paragraph*{}
	Също така от ИП имаме, че $P[x \hookrightarrow N] \equiv P[x \rightsquigarrow N]$, от което и получаваме, че $М[x \hookrightarrow N] \equiv М[x \rightsquigarrow N]$

\subsection*{(2)}
\paragraph*{}
Да разгледаме терма $M = \lambda_y \lambda_x y$. Искаме да направим субституция като заместим $x$ с $y$. Забелязваме, че частичната субституция $M[x \hookrightarrow y]$ е дефинирана и дава $\lambda_y \lambda_x y$. Но наивната субституция не е коректна, понеже $BV(M) = \{ x, y \}$, а $FV(N) = \{ y \}$ (тук $N$ e $y$) и съответно нямат празно сечение.

\end{enumerate}

\section*{Задача 2.5}
\paragraph*{}
Искаме да намерикм $M' \alphaeq M$, такова, че $M'[x \rightsquigarrow N]$ да коректна, тоест $FV(N) \cap BV(M') = \{ \}$. Нека вземем множеството $FV(N) \cap BV(M) = \{ x_1 x_2, ..., x_n\}$. Можем да изберем произволни $\{ z_1, z_2, ..., z_n \}$ извън $FV(N) \cup BV(M)$ (променливите са безкрайно много). Така можем да заместим $x_i$ със $z_i$. По-конкретно $M' \equiv M[x_1 \rightsquigarrow z_1][x_2 \rightsquigarrow z_2]...[x_n \rightsquigarrow z_n]$. Сигурни сме, че така ще сменим само свързани променливи, понеже според конвенцията свободните и свързаните променливи нямат сечение и така можем да сме сигурни, че $M' \alphaeq M$.

\section*{Задача ???}
\paragraph{}
Нека дефинираме $c_i = \lambda_n n c_s c_0$
\begin{enumerate}
	\item Да се докаже, че за произволно $n \in \mathbb{N}$ e изпълнено $c_i c_n \betaeq c_n$.
	\item Вярно ли е, че $c_i \betaetaeq I$?
\end{enumerate}

\subsection*{1}
Ще докажем твърдението с индукция $n \in \mathbb{N}$. Преди това ще забележим, че $c_i c_n \betaeq c_n c_s c_0 = (\lambda_f \lambda_x f^n x) c_s c_n \betaeq c_s^n c_0 $.
\subsubsection*{База}
\paragraph*{}
При $n=0$ имаме, $c_i c_0 \betaeq = c_0 c_s c_0 = (\lambda_f \lambda_x x) c_s c_0 \betaeq c_0$, с което базата е доказана.

\subsubsection*{Индуктивна стъпка}
\paragraph*{}
Нека се опитаме да докажем твърдението за $n+1$. $c_i c_{n+1} \betaeq c_{n+1} c_s c_0 = (\lambda_f \lambda_x f^{n+1} x) c_s c_0 \betaeq c_s^{n+1} c_0$. Използваме дефиницията за $n$-кратна композиция на функция и записваме, че $c_s^{n+1} c_0 = c_s (c_s^n c_0)$. От наблюдението горе се сещаме, че $c_s (c_s^n c_0) \betaeq c_s (c_i c_n)$. От ИП можем да запишем, че $c_s (c_i c_n) \betaeq c_s c_n$. Сега от свойствата на $c_s$ получаваме, че $c_s c_n = c_{n+1}$. По този начин индуктивната стъпка е завършена.


\subsection*{2}
\paragraph*{}
Нека разгледаме $K = \lambda_x \lambda_y x$. Нека приложим $K$ на $c_i$ и на $I$. $I K \betaeq K = A_1$. От друга страна $c_i K \betaeq K c_s c_0 \betaeq c_s = A_2$. Използваме дефиницията за $c_s$ от лекции $c_s = \lambda_n \lambda_f \lambda_x f (n f x)$. Вижда се, че $A_1$ и $A_2$ са два фундаментално различни обекта, понеже ако приложим променлива $a$ към $A_1$ получаваме $A_1 a = Ka \betaeq \lambda_y a$, което е константа функция, а ако се опитаме да приложим променливата $a$ към $A_2$ ще се получи грешка, понеже $A_2 a \betaeq \lambda_f \lambda_x f(afx)$. Това няма как да е валидно, понеже изисква $a$ да бъде функция.

\section*{Задача ????}
\paragraph*{}
В тази задача ще използваме наготово аритметиката с нумералите на Church като ще приемем, че имаме работещи основни аритметични функции за числата, както и за тяхното представяне. За момента ще покажем минимизация само за обикновени функции от вида $f: \mathbb{N} \rightarrow \mathbb{N}$. Тоест няма да имаме "константни аргументи". 
\paragraph*{}
Нека разгледаме терма $\Gamma = \lambda_F \lambda_f \lambda_y (c= (f \; y) c_0) y (F f (c_s \; y))$. Тук функцията $c_s$ дава следващото число, тоест $c_s c_x \betaeq c_{x+1}$. От сега нататък приемаме, че искаме да минимизираме функцията $f_1 \in \Lambda$. Приемаме, че тя има следната семантика $f_1 c_x \betaeq c_y \iff f_2(x) = y$. Термът който ще минимизира $f_1$ ще бъде $s_1 := Y \Gamma f_1$. Ще докажем, че нашия терм $s_1$ има семантиката на функцията 
$s_2(x) =  
  \begin{cases} 
	x & f_2(x) = 0 \\
	s_2(x+1) & \exists y > x : f_2(y) = 0 \\
	$недефинирана $& \not\exists y > x : f_2(y) = 0  
 \end{cases}
$. (тоест, че $s_1 c_x \betaeq c_y \iff s_2(x) = y$). Също и ще покажем, че функцията $s_2$ всъщност извършва минимизацията на $f_2$.

\subsection*{Случай 1: $f_1 c_x \betaeq c_0 \iff f_2(x) = 0$}
\paragraph*{}
Трябва да покажем, че $s_1 c_x \betaeq c_x$. $ \\ $
$s_1 c_x \equiv (Y \Gamma f_1) c_x \equiv ((\lambda_f (\lambda_x f(xx))(\lambda_x f(xx)) ) \Gamma f_1)c_x \betaeq (((\lambda_x \Gamma(xx))(\lambda_x \Gamma(xx)))f_1)c_x \betaeq \Gamma ((\lambda_x \Gamma(xx))(\lambda_x \Gamma(xx))) f_1 c_x$. Нека $\Delta := ((\lambda_x \Gamma(xx))(\lambda_x \Gamma(xx)))$. Тогава $\Gamma ((\lambda_x \Gamma(xx))(\lambda_x \Gamma(xx))) f_1 c_x = \Gamma \Delta f_1 c_x \equiv \lambda_F \lambda_f \lambda_y (c= (f \; y) c_0) y (F f (c_s \; y)) \Delta f_1 c_x \betaeq (c= (f_1 \; c_x) c_0) c_x (\Delta f_1 (c_s \; c_x))$. От допускането можем да презапишем този израз като $(c= c_0 c_0) c_x (\Delta f_1 (c_s \; c_x)) \betaeq c_t c_x (\Delta f_1 (c_s \; c_x)) \betaeq c_x$. По този начин довършваме случая.  

\subsection*{Случай 2: $f_1 c_x \not\betaeq c_0 \iff f_2(x) \neq 0$ и $s_2(x)$ е дефинирано}
\paragraph*{}
В този случай трябва да покажем, че $s_1 c_x \betaeq s_1 c_{x+1}$. По-късно ще видим като доказваме коректността на функцията $s_2$, че $s_1 c_{x+1}$ ще бъде $\lambda$-определимо. Подобно на миналия случай започваме да правим $\beta$-редукции $s_1 c_x \equiv (Y \Gamma f_1) c_x \betaeq ... \betaeq (c= (f_1 \; c_x) c_0) c_x (\Delta f_1 (c_s \; c_x)).$ От предположението знаем, че този израз е $\beta$-еквивалентен на $c_f c_x (\Delta f_1 (c_s \; c_x)) \betaeq \Delta f_1 (c_s \; c_x) \equiv ((\lambda_x \Gamma(xx))(\lambda_x \Gamma(xx))) f_1 (c_s \; c_x) \betaeq Y \Gamma f_1 (c_s \; c_x) \betaeq Y \Gamma f_1 c_{x+1} \equiv s_1 c_{x+1}$. Така доказахме случая.

\subsection*{Случай 3:  $s_2(x)$ не е дефинирано}
\paragraph*{}
Тук трябва да покажем, че $s_1 c_{x}$ няма нормална форма. 

\end{document}